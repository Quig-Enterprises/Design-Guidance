/# Hybrid Dependency Management Approach
/
/## 1. Overview
/
/The Hybrid Dependency Management Approach is the official CxQ standard for building professional, maintainable, and user-friendly WordPress plugins. It combines the power of modern development tools like Composer with the simplicity of a bundled, zero-configuration deployment that WordPress users expect.
/
/**This approach is defined by two distinct states:**
/1.  **During Development:** We use Composer to manage all dependencies, including shared CxQ libraries and external packages. This provides us with version control, autoloading, and a clean project structure.
/2.  **For Production (Deployment):** We use a build process to bundle all dependencies into the final plugin `.zip` file. This creates a self-contained plugin that requires no shell access or extra steps from the end-user.
/
/### 1.1. Benefits of the Hybrid Approach
/- **Professional Architecture:** Leverages modern PHP standards like PSR-4 autoloading and proper dependency management.
/- **User-Friendly Deployment:** The final product is a simple `.zip` file that works immediately upon upload to WordPress.
/- **Reliability & Security:** By bundling and locally hosting assets, we eliminate reliance on external CDNs, improving privacy, security, and uptime.
/- **Maintainability:** Code is cleaner, more organized, and easier to update and test.
/
/### 1.2. When to Use This Approach
/
/This is the **default and recommended approach** for all CxQ WordPress plugins.
/
/| Use Hybrid Approach If... | Do NOT Use Hybrid Approach If... |
/| :--- | :--- |
/| ✅ Building a WordPress plugin for distribution. | ❌ Building a non-WordPress web application. |
/| ✅ The plugin uses one or more shared CxQ libraries. | ❌ Building a simple, single-file plugin with no dependencies. |
/| ✅ The plugin relies on external PHP or JS/CSS assets. | ❌ Working on a project where Composer is guaranteed to be available on the production server (e.g., internal CLI tools). |
/| ✅ The plugin will be distributed via WordPress.org or direct download. | |
/
/---
/
/## 2. Architecture and Directory Structure
/
/A key aspect of this approach is a standardized directory structure that separates source code, development tools, and production-ready bundled assets.
/
/```
//plugin-name/
/|
/|-- /assets/
/|   |-- /css/
/|   |-- /js/
/|   `-- /vendor/                    # Bundled EXTERNAL assets (e.g., Chart.js)
/|
/|-- /build/                         # Build scripts (DEV-ONLY, not in final zip)
/|   `-- build-plugin.sh
/|
/|-- /includes/                      # Legacy or non-class based PHP files
/|
/|-- /languages/                     # Translation files
/|
/|-- /src/                           # All PSR-4 namespaced plugin source code
/|   |-- Admin/
/|   |-- Core/
/|   `-- ...
/|
/|-- /vendor/                        # Bundled PHP dependencies (PRODUCTION)
/|   |-- autoload.php
/|   |-- composer/
/|   `-- quig-enterprises/
/|
/|-- composer.json                   # Defines all dependencies (for development)
/|-- composer.lock                   # Locks dependency versions for consistent builds
/|-- plugin-name.php                 # Main plugin bootstrap file
/`-- uninstall.php                   # Uninstallation script
/```
/
/*   **`/src`**: Contains all of your plugin's original, PSR-4 namespaced PHP code.
/*   **`/vendor`**: This directory is **generated by Composer** during the build process. It contains all required PHP libraries (like `cxq-util-data-logger`) and the crucial `autoload.php` file. It **must** be included in the final `.zip` file.
/*   **`/assets/vendor`**: This directory is for **front-end assets** (like JavaScript libraries or CSS frameworks) that you have chosen to bundle locally instead of using a CDN.
/*   **`/build`**: Contains scripts used to assemble the final `.zip` file. This directory **must not** be included in the final distributable.
/*   **`composer.json` / `composer.lock`**: These files define the project's dependencies for development and are **not required** for the plugin to run in production, but should be included for reference.
/
/---
/
/## 3. Implementation Guidelines
/
/### 3.1. `composer.json` Structure
/
/Your plugin's `composer.json` should define its own name, require the necessary CxQ libraries, and map the `/src` directory to your plugin's namespace.
/
/```json
/{
/    "name": "quig-enterprises/cxq-auditor",
/    "description": "Provides auditing capabilities for WordPress.",
/    "type": "wordpress-plugin",
/    "require": {
/        "php": ">=7.4",
/        "quig-enterprises/cxq-util-data-logger": "dev-main",
/        "quig-enterprises/cxq-util-post-type-manager": "dev-main"
/    },
/    "autoload": {
/        "psr-4": {
/            "CxQ\\Auditor\\": "src/"
/        }
/    },
/    "repositories": [
/        {
/            "type": "vcs",
/            "url": "https://github.com/Quig-Enterprises/cxq-libs.git"
/        }
/    ]
/}
/```
/
/### 3.2. The Main Plugin File (`plugin-name.php`)
/
/The main plugin file is the bootstrap. Its most important job is to load the Composer autoloader, which makes all your classes and library classes available.
/
/```php
/<?php
//**
/ * Plugin Name: CxQ Auditor
/ * ... (rest of header) ...
/ */
/
/// If this file is called directly, abort.
/if ( ! defined( 'WPINC' ) ) {
/    die;
/}
/
/// 1. Load the Composer autoloader.
/if ( file_exists( __DIR__ . '/vendor/autoload.php' ) ) {
/    require_once __DIR__ . '/vendor/autoload.php';
/} else {
/    // Optional: Add an admin notice if the vendor directory is missing.
/    // This helps during development if `composer install` hasn't been run.
/    return;
/}
/
/// 2. Instantiate and run the main plugin class.
/function run_cxq_auditor() {
/    $plugin = new \CxQ\Auditor\Core\Plugin();
/    $plugin->run();
/}
/
/run_cxq_auditor();
/```
/
/---
/
/## 4. Build Process
/
/A build script is essential for creating a clean, production-ready `.zip` file. While the implementation can vary, it must perform the following steps:
/
/1.  **Create a Temporary Build Directory:** Copy the plugin's source files to a temporary location (e.g., `/build/dist/`).
/2.  **Install Production Dependencies:** Run `composer install --no-dev --optimize-autoloader` inside the temporary directory. This installs only the required libraries and creates a highly optimized autoloader.
/3.  **Remove Development Files:** Delete any files and directories not needed for production (e.g., the `/build` folder itself, `.git`, `.github`, etc.).
/4.  **Bundle External Assets:** If the project requires external JS/CSS, the script should download them into the `/assets/vendor/` directory.
/5.  **Create the Zip Archive:** Create the final, versioned `.zip` file (e.g., `cxq-auditor-1.2.0.zip`) from the contents of the cleaned temporary directory.
/
/---
/
/## 5. External Asset Management
/
/For security, privacy (GDPR), and reliability, we **do not use external CDNs** for third-party assets like JavaScript libraries or fonts.
/
/*   **Requirement:** All external front-end assets must be downloaded and included within the plugin, typically in the `/assets/vendor/` directory.
/*   **Responsibility:** The plugin is responsible for properly enqueuing these local assets using `wp_enqueue_script()` and `wp_enqueue_style()`.
/*   **Security:** Always download assets from their official source (e.g., GitHub releases, npm) and verify their integrity.
